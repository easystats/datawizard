
R version 4.2.2 (2022-10-31 ucrt) -- "Innocent and Trusting"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "sjPlot"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('sjPlot')
Learn more about sjPlot with 'browseVignettes("sjPlot")'.
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("dist_chisq")
> ### * dist_chisq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_chisq
> ### Title: Plot chi-squared distributions
> ### Aliases: dist_chisq
> 
> ### ** Examples
> 
> # a simple chi-squared distribution
> # for 6 degrees of freedom
> dist_chisq(deg.f = 6)
> 
> # a chi-squared distribution for 6 degrees of freedom,
> # and a shaded area starting at chi-squared value of ten.
> # With a df of 6, a chi-squared value of 12.59 would be "significant",
> # thus the shaded area from 10 to 12.58 is filled as "non-significant",
> # while the area starting from chi-squared value 12.59 is filled as
> # "significant"
> dist_chisq(chi2 = 10, deg.f = 6)
> 
> # a chi-squared distribution for 6 degrees of freedom,
> # and a shaded area starting at that chi-squared value, which has
> # a p-level of about 0.125 (which equals a chi-squared value of about 10).
> # With a df of 6, a chi-squared value of 12.59 would be "significant",
> # thus the shaded area from 10 to 12.58 (p-level 0.125 to p-level 0.05)
> # is filled as "non-significant", while the area starting from chi-squared
> # value 12.59 (p-level < 0.05) is filled as "significant".
> dist_chisq(p = 0.125, deg.f = 6)
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_f")
> ### * dist_f
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_f
> ### Title: Plot F distributions
> ### Aliases: dist_f
> 
> ### ** Examples
> 
> # a simple F distribution for 6 and 45 degrees of freedom
> dist_f(deg.f1 = 6, deg.f2 = 45)
> 
> # F distribution for 6 and 45 degrees of freedom,
> # and a shaded area starting at F value of two.
> # F-values equal or greater than 2.31 are "significant"
> dist_f(f = 2, deg.f1 = 6, deg.f2 = 45)
> 
> # F distribution for 6 and 45 degrees of freedom,
> # and a shaded area starting at a p-level of 0.2
> # (F-Value about 1.5).
> dist_f(p = 0.2, deg.f1 = 6, deg.f2 = 45)
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_norm")
> ### * dist_norm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_norm
> ### Title: Plot normal distributions
> ### Aliases: dist_norm
> 
> ### ** Examples
> 
> # a simple normal distribution
> dist_norm()
> 
> # a simple normal distribution with different mean and sd.
> # note that curve looks similar to above plot, but axis range
> # has changed.
> dist_norm(mean = 2, sd = 4)
> 
> # a simple normal distribution
> dist_norm(norm = 1)
> 
> # a simple normal distribution
> dist_norm(p = 0.2)
> 
> 
> 
> 
> cleanEx()
> nameEx("dist_t")
> ### * dist_t
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dist_t
> ### Title: Plot t-distributions
> ### Aliases: dist_t
> 
> ### ** Examples
> 
> # a simple t-distribution
> # for 6 degrees of freedom
> dist_t(deg.f = 6)
> 
> # a t-distribution for 6 degrees of freedom,
> # and a shaded area starting at t-value of one.
> # With a df of 6, a t-value of 1.94 would be "significant".
> dist_t(t = 1, deg.f = 6)
> 
> # a t-distribution for 6 degrees of freedom,
> # and a shaded area starting at p-level of 0.4
> # (t-value of about 0.26).
> dist_t(p = 0.4, deg.f = 6)
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_frq")
> ### * plot_frq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_frq
> ### Title: Plot frequencies of variables
> ### Aliases: plot_frq
> 
> ### ** Examples
> 
> library(sjlabelled)
> data(efc)
> data(iris)
> 
> # simple plots, two different notations
> plot_frq(iris, Species)
> plot_frq(efc$tot_sc_e)
> 
> # boxplot
> plot_frq(efc$e17age, type = "box")
Warning: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0.
ℹ Please use the `fun` argument instead.
ℹ The deprecated feature was likely used in the sjPlot package.
  Please report the issue at <https://github.com/strengejacke/sjPlot/issues>.
> 
> if (require("dplyr")) {
+   # histogram, pipe-workflow
+   efc %>%
+     dplyr::select(e17age, c160age) %>%
+     plot_frq(type = "hist", show.mean = TRUE)
+ 
+   # bar plot(s)
+   plot_frq(efc, e42dep, c172code)
+ }
Loading required package: dplyr

Attaching package: 'dplyr'

The following object is masked from 'package:sjlabelled':

    as_label

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

[[1]]

[[2]]

> 
> if (require("dplyr") && require("gridExtra")) {
+   # grouped data frame, all panels in one plot
+   efc %>%
+     group_by(e42dep) %>%
+     plot_frq(c161sex) %>%
+     plot_grid()
+ }
Loading required package: gridExtra

Attaching package: 'gridExtra'

The following object is masked from 'package:dplyr':

    combine

Warning in plot_grid(.) :
  Not enough tags labels in list. Using letters instead.
> 
> 
> 
> 
> cleanEx()

detaching 'package:gridExtra', 'package:dplyr', 'package:sjlabelled'

> nameEx("plot_gpt")
> ### * plot_gpt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_gpt
> ### Title: Plot grouped proportional tables
> ### Aliases: plot_gpt
> 
> ### ** Examples
> 
> data(efc)
> 
> # the proportion of dependency levels in female
> # elderly, for each family carer's relationship
> # to elderly
> plot_gpt(efc, e42dep, e16sex, e15relat)
> 
> # proportion of educational levels in highest
> # dependency category of elderly, for different
> # care levels
> plot_gpt(efc, c172code, e42dep, n4pstu)
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_grid")
> ### * plot_grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_grid
> ### Title: Arrange list of plots as grid
> ### Aliases: plot_grid
> 
> ### ** Examples
> 
> if (require("dplyr") && require("gridExtra")) {
+   library(ggeffects)
+   data(efc)
+ 
+   # fit model
+   fit <- glm(
+     tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
+     data = efc,
+     family = poisson
+   )
+ 
+   # plot marginal effects for each predictor, each as single plot
+   p1 <- ggpredict(fit, "c12hour") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+   p2 <- ggpredict(fit, "e17age") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+   p3 <- ggpredict(fit, "e42dep") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+   p4 <- ggpredict(fit, "neg_c_7") %>%
+     plot(show.y.title = FALSE, show.title = FALSE)
+ 
+   # plot grid
+   plot_grid(list(p1, p2, p3, p4))
+ 
+   # plot grid
+   plot_grid(list(p1, p2, p3, p4), tags = TRUE)
+ }
Loading required package: dplyr

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

Loading required package: gridExtra

Attaching package: 'gridExtra'

The following object is masked from 'package:dplyr':

    combine

Warning in plot_grid(list(p1, p2, p3, p4)) :
  Not enough tags labels in list. Using letters instead.
> 
> 
> 
> cleanEx()

detaching 'package:ggeffects', 'package:gridExtra', 'package:dplyr'

> nameEx("plot_grpfrq")
> ### * plot_grpfrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_grpfrq
> ### Title: Plot grouped or stacked frequencies
> ### Aliases: plot_grpfrq
> 
> ### ** Examples
> 
> data(efc)
> plot_grpfrq(efc$e17age, efc$e16sex, show.values = FALSE)
> 
> # boxplot
> plot_grpfrq(efc$e17age, efc$e42dep, type = "box")
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
> 
> # grouped bars
> plot_grpfrq(efc$e42dep, efc$e16sex, title = NULL)
> 
> # box plots with interaction variable
> plot_grpfrq(efc$e17age, efc$e42dep, intr.var = efc$e16sex, type = "box")
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
Warning in rq.fit.br(wx, wy, tau = tau, ...) :
  Solution may be nonunique
> 
> # Grouped bar plot
> plot_grpfrq(efc$neg_c_7, efc$e42dep, show.values = FALSE)
> 
> # same data as line plot
> plot_grpfrq(efc$neg_c_7, efc$e42dep, type = "line")
> 
> # show ony categories where we have data (i.e. drop zero-counts)
> library(dplyr)

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

> efc <- dplyr::filter(efc, e42dep %in% c(3,4))
> plot_grpfrq(efc$c161sex, efc$e42dep, drop.empty = TRUE)
> 
> # show all categories, even if not in data
> plot_grpfrq(efc$c161sex, efc$e42dep, drop.empty = FALSE)
> 
> 
> 
> 
> cleanEx()

detaching 'package:dplyr'

> nameEx("plot_kfold_cv")
> ### * plot_kfold_cv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_kfold_cv
> ### Title: Plot model fit from k-fold cross-validation
> ### Aliases: plot_kfold_cv
> 
> ### ** Examples
> 
> data(efc)
> 
> plot_kfold_cv(efc, neg_c_7 ~ e42dep + c172code + c12hour)
`geom_smooth()` using formula = 'y ~ x'
Warning: Removed 119 rows containing non-finite values (`stat_smooth()`).
Warning: Removed 119 rows containing missing values (`geom_point()`).
> plot_kfold_cv(mtcars, mpg ~.)
`geom_smooth()` using formula = 'y ~ x'
> 
> # for poisson models. need to fit a model and use 'fit'-argument
> fit <- glm(tot_sc_e ~ neg_c_7 + c172code, data = efc, family = poisson)
> plot_kfold_cv(efc, fit = fit)
`geom_smooth()` using formula = 'y ~ x'
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  pseudoinverse used at -0.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  neighborhood radius 1.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  reciprocal condition number  1.3296e-28
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  There are other near singularities as well. 1
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  pseudoinverse used at -0.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  neighborhood radius 1.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  reciprocal condition number  1.3296e-28
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  There are other near singularities as well. 1
> 
> # and for negative binomial models
> fit <- MASS::glm.nb(tot_sc_e ~ neg_c_7 + c172code, data = efc)
> plot_kfold_cv(efc, fit = fit)
`geom_smooth()` using formula = 'y ~ x'
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  pseudoinverse used at -0.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  neighborhood radius 1.045
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  reciprocal condition number  3.5959e-28
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  There are other near singularities as well. 1
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  pseudoinverse used at -0.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  neighborhood radius 1.045
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  reciprocal condition number  3.5959e-28
Warning in predLoess(object$y, object$x, newx = if (is.null(newdata)) object$x else if (is.data.frame(newdata)) as.matrix(model.frame(delete.response(terms(object)),  :
  There are other near singularities as well. 1
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_likert")
> ### * plot_likert
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_likert
> ### Title: Plot likert scales as centered stacked bars
> ### Aliases: plot_likert
> 
> ### ** Examples
> 
> library(sjmisc)
> data(efc)
> # find all variables from COPE-Index, which all have a "cop" in their
> # variable name, and then plot that subset as likert-plot
> mydf <- find_var(efc, pattern = "cop", out = "df")
> 
> plot_likert(mydf)
> 
> plot_likert(
+   mydf,
+   grid.range = c(1.2, 1.4),
+   expand.grid = FALSE,
+   values = "sum.outside",
+   show.prc.sign = TRUE
+ )
> 
> # Plot in groups
> 
> plot_likert(mydf, c(2,1,1,1,1,2,2,2,1))
> 
> if (require("parameters") && require("nFactors")) {
+   groups <- parameters::principal_components(mydf)
+   plot_likert(mydf, groups = parameters::closest_component(groups))
+ }
Loading required package: parameters
Loading required package: nFactors
Loading required package: lattice

Attaching package: 'nFactors'

The following object is masked from 'package:lattice':

    parallel

> 
> plot_likert(mydf,
+             c(rep("B", 4), rep("A", 5)),
+             sort.groups = FALSE,
+             grid.range = c(0.9, 1.1),
+             geom.colors = "RdBu",
+             rel_heights = c(6, 8),
+             wrap.labels = 40,
+             reverse.scale = TRUE)
> 
> # control legend items
> six_cat_example = data.frame(
+   matrix(sample(1:6, 600, replace = TRUE),
+   ncol = 6)
+ )
> 
> ## Not run: 
> ##D six_cat_example <-
> ##D   six_cat_example %>%
> ##D   dplyr::mutate_all(~ordered(.,labels = c("+++","++","+","-","--","---")))
> ##D 
> ##D # Old default
> ##D plot_likert(
> ##D   six_cat_example,
> ##D   groups = c(1, 1, 1, 2, 2, 2),
> ##D   group.legend.options = list(nrow = 2, byrow = FALSE)
> ##D )
> ##D 
> ##D # New default
> ##D plot_likert(six_cat_example, groups = c(1, 1, 1, 2, 2, 2))
> ##D 
> ##D # Single row
> ##D plot_likert(
> ##D   six_cat_example,
> ##D   groups = c(1, 1, 1, 2, 2, 2),
> ##D   group.legend.options = list(nrow = 1)
> ##D )
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching 'package:nFactors', 'package:lattice', 'package:parameters',
  'package:sjmisc'

> nameEx("plot_model")
> ### * plot_model
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_model
> ### Title: Plot regression models
> ### Aliases: plot_model get_model_data
> 
> ### ** Examples
> 
> # prepare data
> library(sjmisc)
> data(efc)
> efc <- to_factor(efc, c161sex, e42dep, c172code)
> m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
> 
> # simple forest plot
> plot_model(m)
> 
> # grouped coefficients
> plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))
> 
> # keep only selected terms in the model: pos_v_4, the
> # levels 3 and 4 of factor e42dep and levels 2 and 3 for c172code
> plot_model(m, terms = c("pos_v_4", "e42dep [3,4]", "c172code [2,3]"))
> 
> # multiple plots, as returned from "diagnostic"-plot type,
> # can be arranged with 'plot_grid()'
> ## Not run: 
> ##D p <- plot_model(m, type = "diag")
> ##D plot_grid(p)
> ## End(Not run)
> 
> # plot random effects
> if (require("lme4") && require("glmmTMB")) {
+   m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
+   plot_model(m, type = "re")
+ 
+   # plot marginal effects
+   plot_model(m, type = "pred", terms = "Days")
+ }
Loading required package: lme4
Loading required package: Matrix
Loading required package: glmmTMB
> # plot interactions
> ## Not run: 
> ##D m <- glm(
> ##D   tot_sc_e ~ c161sex + c172code * neg_c_7,
> ##D   data = efc,
> ##D   family = poisson()
> ##D )
> ##D # type = "int" automatically selects groups for continuous moderator
> ##D # variables - see argument 'mdrt.values'. The following function call is
> ##D # identical to:
> ##D # plot_model(m, type = "pred", terms = c("c172code", "neg_c_7 [7,28]"))
> ##D plot_model(m, type = "int")
> ##D 
> ##D # switch moderator
> ##D plot_model(m, type = "pred", terms = c("neg_c_7", "c172code"))
> ##D # same as
> ##D # ggeffects::ggpredict(m, terms = c("neg_c_7", "c172code"))
> ## End(Not run)
> 
> # plot Stan-model
> ## Not run: 
> ##D if (require("rstanarm")) {
> ##D   data(mtcars)
> ##D   m <- stan_glm(mpg ~ wt + am + cyl + gear, data = mtcars, chains = 1)
> ##D   plot_model(m, bpe.style = "dot")
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching 'package:glmmTMB', 'package:lme4', 'package:Matrix',
  'package:sjmisc'

> nameEx("plot_models")
> ### * plot_models
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_models
> ### Title: Forest plot of multiple regression models
> ### Aliases: plot_models
> 
> ### ** Examples
> 
> data(efc)
> 
> # fit three models
> fit1 <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data = efc)
> fit2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + c172code, data = efc)
> fit3 <- lm(tot_sc_e ~ c160age + c12hour + c161sex + c172code, data = efc)
> 
> # plot multiple models
> plot_models(fit1, fit2, fit3, grid = TRUE)
> 
> # plot multiple models with legend labels and
> # point shapes instead of value labels
> plot_models(
+   fit1, fit2, fit3,
+   axis.labels = c(
+     "Carer's Age", "Hours of Care", "Carer's Sex", "Educational Status"
+   ),
+   m.labels = c("Barthel Index", "Negative Impact", "Services used"),
+   show.values = FALSE, show.p = FALSE, p.shape = TRUE
+ )
> 
> ## Not run: 
> ##D # plot multiple models from nested lists argument
> ##D all.models <- list()
> ##D all.models[[1]] <- fit1
> ##D all.models[[2]] <- fit2
> ##D all.models[[3]] <- fit3
> ##D 
> ##D plot_models(all.models)
> ##D 
> ##D # plot multiple models with different predictors (stepwise inclusion),
> ##D # standardized estimates
> ##D fit1 <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars)
> ##D fit2 <- update(fit1, . ~ . + hp)
> ##D fit3 <- update(fit2, . ~ . + am)
> ##D 
> ##D plot_models(fit1, fit2, fit3, std.est = "std2")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot_residuals")
> ### * plot_residuals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_residuals
> ### Title: Plot predicted values and their residuals
> ### Aliases: plot_residuals
> 
> ### ** Examples
> 
> data(efc)
> # fit model
> fit <- lm(neg_c_7 ~ c12hour + e17age + e42dep, data = efc)
> 
> # plot residuals for all independent variables
> plot_residuals(fit)
`geom_smooth()` using formula = 'y ~ x'
> 
> # remove some independent variables from output
> plot_residuals(fit, remove.estimates = c("e17age", "e42dep"))
`geom_smooth()` using formula = 'y ~ x'
> 
> 
> 
> 
> cleanEx()
> nameEx("plot_scatter")
> ### * plot_scatter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_scatter
> ### Title: Plot (grouped) scatter plots
> ### Aliases: plot_scatter
> 
> ### ** Examples
> 
> # load sample date
> library(sjmisc)
> library(sjlabelled)
> data(efc)
> 
> # simple scatter plot
> plot_scatter(efc, e16sex, neg_c_7)
> 
> # simple scatter plot, increased jittering
> plot_scatter(efc, e16sex, neg_c_7, jitter = .4)
> 
> # grouped scatter plot
> plot_scatter(efc, c160age, e17age, e42dep)
> 
> # grouped scatter plot with marginal rug plot
> # and add fitted line for complete data
> plot_scatter(
+   efc, c12hour, c160age, c172code,
+   show.rug = TRUE, fit.line = "lm"
+ )
`geom_smooth()` using formula = 'y ~ x'
> 
> # grouped scatter plot with marginal rug plot
> # and add fitted line for each group
> plot_scatter(
+   efc, c12hour, c160age, c172code,
+   show.rug = TRUE, fit.grps = "loess",
+   grid = TRUE
+ )
`geom_smooth()` using formula = 'y ~ x'
> 
> 
> 
> 
> cleanEx()

detaching 'package:sjlabelled', 'package:sjmisc'

> nameEx("plot_stackfrq")
> ### * plot_stackfrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_stackfrq
> ### Title: Plot stacked proportional bars
> ### Aliases: plot_stackfrq
> 
> ### ** Examples
> 
> # Data from the EUROFAMCARE sample dataset
> library(sjmisc)
> data(efc)
> # recveive first item of COPE-index scale
> start <- which(colnames(efc) == "c82cop1")
> # recveive first item of COPE-index scale
> end <- which(colnames(efc) == "c90cop9")
> # auto-detection of labels
> plot_stackfrq(efc[, start:end])
> 
> # works on grouped data frames as well
> library(dplyr)

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

> efc %>%
+   group_by(c161sex) %>%
+   select(start:end) %>%
+   plot_stackfrq()
Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.
ℹ Please use `all_of()` or `any_of()` instead.
  # Was:
  data %>% select(start)

  # Now:
  data %>% select(all_of(start))

See <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.
Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.
ℹ Please use `all_of()` or `any_of()` instead.
  # Was:
  data %>% select(end)

  # Now:
  data %>% select(all_of(end))

See <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.
Adding missing grouping variables: `c161sex`
[[1]]
[[1]][[1]]
NULL

[[1]][[2]]


[[2]]

> 
> 
> 
> 
> cleanEx()

detaching 'package:dplyr', 'package:sjmisc'

> nameEx("plot_xtab")
> ### * plot_xtab
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot_xtab
> ### Title: Plot contingency tables
> ### Aliases: plot_xtab
> 
> ### ** Examples
> 
> # create 4-category-items
> grp <- sample(1:4, 100, replace = TRUE)
> # create 3-category-items
> x <- sample(1:3, 100, replace = TRUE)
> 
> # plot "cross tablulation" of x and grp
> plot_xtab(x, grp)
> 
> # plot "cross tablulation" of x and y, including labels
> plot_xtab(x, grp, axis.labels = c("low", "mid", "high"),
+          legend.labels = c("Grp 1", "Grp 2", "Grp 3", "Grp 4"))
> 
> # plot "cross tablulation" of x and grp
> # as stacked proportional bars
> plot_xtab(x, grp, margin = "row", bar.pos = "stack",
+          show.summary = TRUE, coord.flip = TRUE)
> 
> # example with vertical labels
> library(sjmisc)
> library(sjlabelled)
> data(efc)
> set_theme(geom.label.angle = 90)
> plot_xtab(efc$e42dep, efc$e16sex, vjust = "center", hjust = "bottom")
> 
> # grouped bars with EUROFAMCARE sample dataset
> # dataset was importet from an SPSS-file,
> # see ?sjmisc::read_spss
> data(efc)
> efc.val <- get_labels(efc)
> efc.var <- get_label(efc)
> 
> plot_xtab(efc$e42dep, efc$e16sex, title = efc.var['e42dep'],
+          axis.labels = efc.val[['e42dep']], legend.title = efc.var['e16sex'],
+          legend.labels = efc.val[['e16sex']])
> 
> plot_xtab(efc$e16sex, efc$e42dep, title = efc.var['e16sex'],
+          axis.labels = efc.val[['e16sex']], legend.title = efc.var['e42dep'],
+          legend.labels = efc.val[['e42dep']])
> 
> # -------------------------------
> # auto-detection of labels works here
> # so no need to specify labels. For
> # title-auto-detection, use NULL
> # -------------------------------
> plot_xtab(efc$e16sex, efc$e42dep, title = NULL)
> 
> plot_xtab(efc$e16sex, efc$e42dep, margin = "row",
+          bar.pos = "stack", coord.flip = TRUE)
> 
> 
> 
> 
> cleanEx()

detaching 'package:sjlabelled', 'package:sjmisc'

> nameEx("set_theme")
> ### * set_theme
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: set_theme
> ### Title: Set global theme options for sjp-functions
> ### Aliases: set_theme
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(sjmisc)
> ##D data(efc)
> ##D # set sjPlot-defaults, a slightly modification
> ##D # of the ggplot base theme
> ##D set_theme()
> ##D 
> ##D # legends of all plots inside
> ##D set_theme(legend.pos = "top left", legend.inside = TRUE)
> ##D plot_xtab(efc$e42dep, efc$e16sex)
> ##D 
> ##D # Use classic-theme. you may need to
> ##D # load the ggplot2-library.
> ##D library(ggplot2)
> ##D set_theme(base = theme_classic())
> ##D plot_frq(efc$e42dep)
> ##D 
> ##D # adjust value labels
> ##D set_theme(
> ##D   geom.label.size = 3.5,
> ##D   geom.label.color = "#3366cc",
> ##D   geom.label.angle = 90
> ##D )
> ##D 
> ##D # hjust-aes needs adjustment for this
> ##D update_geom_defaults('text', list(hjust = -0.1))
> ##D plot_xtab(efc$e42dep, efc$e16sex, vjust = "center", hjust = "center")
> ##D 
> ##D # Create own theme based on classic-theme
> ##D set_theme(
> ##D   base = theme_classic(), axis.linecolor = "grey50",
> ##D   axis.textcolor = "#6699cc"
> ##D )
> ##D plot_frq(efc$e42dep)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("sjPlot-themes")
> ### * sjPlot-themes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjPlot-themes
> ### Title: Modify plot appearance
> ### Aliases: sjPlot-themes theme_sjplot theme_sjplot2 theme_blank theme_538
> ###   font_size label_angle legend_style scale_color_sjplot
> ###   scale_fill_sjplot sjplot_pal show_sjplot_pals css_theme
> 
> ### ** Examples
> 
> # prepare data
> library(sjmisc)
> data(efc)
> efc <- to_factor(efc, c161sex, e42dep, c172code)
> m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
> 
> # create plot-object
> p <- plot_model(m)
> 
> # change theme
> p + theme_sjplot()
> 
> # change font-size
> p + font_size(axis_title.x = 30)
> 
> # apply color theme
> p + scale_color_sjplot()
Scale for colour is already present.
Adding another scale for colour, which will replace the existing scale.
> 
> # show all available colour palettes
> show_sjplot_pals()
> 
> # get colour values from specific palette
> sjplot_pal(pal = "breakfast club")
[1] "#b6411a" "#4182dd" "#2d6328" "#eec3d8" "#ecf0c8"
> 
> 
> 
> 
> cleanEx()

detaching 'package:sjmisc'

> nameEx("sjp.aov1")
> ### * sjp.aov1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjp.aov1
> ### Title: Plot One-Way-Anova tables
> ### Aliases: sjp.aov1
> 
> ### ** Examples
> 
> data(efc)
> # note: "var.grp" does not need to be a factor.
> # coercion to factor is done by the function
> sjp.aov1(efc$c12hour, efc$e42dep)
Warning: Continuous limits supplied to discrete scale.
ℹ Did you mean `limits = factor(...)` or `scale_*_continuous()`?
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("sjp.chi2")
> ### * sjp.chi2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjp.chi2
> ### Title: Plot Pearson's Chi2-Test of multiple contingency tables
> ### Aliases: sjp.chi2
> 
> ### ** Examples
> 
> # create data frame with 5 dichotomous (dummy) variables
> mydf <- data.frame(as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)),
+                    as.factor(sample(1:2, 100, replace=TRUE)))
> # create variable labels
> items <- list(c("Item 1", "Item 2", "Item 3", "Item 4", "Item 5"))
> 
> # plot Chi2-contingency-table
> sjp.chi2(mydf, axis.labels = items)
> 
> 
> 
> 
> cleanEx()
> nameEx("sjp.poly")
> ### * sjp.poly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjp.poly
> ### Title: Plot polynomials for (generalized) linear regression
> ### Aliases: sjp.poly
> 
> ### ** Examples
> 
> library(sjmisc)
> data(efc)
> # linear fit. loess-smoothed line indicates a more
> # or less cubic curve
> sjp.poly(efc$c160age, efc$quol_5, 1)
Polynomial degrees: 1
---------------------
p(x^1): 0.000

`geom_smooth()` using formula = 'y ~ x'
> 
> # quadratic fit
> sjp.poly(efc$c160age, efc$quol_5, 2)
Polynomial degrees: 2
---------------------
p(x^1): 0.078
p(x^2): 0.533

`geom_smooth()` using formula = 'y ~ x'
> 
> # linear to cubic fit
> sjp.poly(efc$c160age, efc$quol_5, 1:4, show.scatter = FALSE)
Polynomial degrees: 1
---------------------
p(x^1): 0.000

Polynomial degrees: 2
---------------------
p(x^1): 0.078
p(x^2): 0.533

Polynomial degrees: 3
---------------------
p(x^1): 0.012
p(x^2): 0.001
p(x^3): 0.000

Polynomial degrees: 4
---------------------
p(x^1): 0.777
p(x^2): 0.913
p(x^3): 0.505
p(x^4): 0.254

`geom_smooth()` using formula = 'y ~ x'
> 
> 
> # fit sample model
> fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data = efc)
> # inspect relationship between predictors and response
> plot_model(fit, type = "slope")
`geom_smooth()` using formula = 'y ~ x'
`geom_smooth()` using formula = 'y ~ x'
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  pseudoinverse used at 4.015
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  neighborhood radius 2.015
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  reciprocal condition number  2.8666e-15
Warning in simpleLoess(y, x, w, span, degree = degree, parametric = parametric,  :
  There are other near singularities as well. 1
> # "e17age" does not seem to be linear correlated to response
> # try to find appropiate polynomial. Grey line (loess smoothed)
> # indicates best fit. Looks like x^4 has the best fit,
> # however, only x^3 has significant p-values.
> sjp.poly(fit, "e17age", 2:4, show.scatter = FALSE)
Polynomial degrees: 2
---------------------
p(x^1): 0.734
p(x^2): 0.721

Polynomial degrees: 3
---------------------
p(x^1): 0.010
p(x^2): 0.011
p(x^3): 0.011

Polynomial degrees: 4
---------------------
p(x^1): 0.234
p(x^2): 0.267
p(x^3): 0.303
p(x^4): 0.343

`geom_smooth()` using formula = 'y ~ x'
> 
> ## Not run: 
> ##D # fit new model
> ##D fit <- lm(tot_sc_e ~ c12hour + e42dep + e17age + I(e17age^2) + I(e17age^3),
> ##D           data = efc)
> ##D # plot marginal effects of polynomial term
> ##D plot_model(fit, type = "pred", terms = "e17age")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching 'package:sjmisc'

> nameEx("sjplot")
> ### * sjplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sjplot
> ### Title: Wrapper to create plots and tables within a pipe-workflow
> ### Aliases: sjplot sjtab
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

> data(efc)
> 
> # Grouped frequencies
> efc %>% sjplot(e42dep, c172code, fun = "grpfrq")
> 
> # Grouped frequencies, as box plots
> efc %>% sjplot(e17age, c172code, fun = "grpfrq",
+                type = "box", geom.colors = "Set1")
> 
> ## Not run: 
> ##D # table output of grouped data frame
> ##D efc %>%
> ##D   group_by(e16sex, c172code) %>%
> ##D   select(e42dep, n4pstu, e16sex, c172code) %>%
> ##D   sjtab(fun = "xtab", use.viewer = FALSE) # open all tables in browser
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching 'package:dplyr'

> nameEx("tab_corr")
> ### * tab_corr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_corr
> ### Title: Summary of correlations as HTML table
> ### Aliases: tab_corr
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (interactive()) {
> ##D   # Data from the EUROFAMCARE sample dataset
> ##D   library(sjmisc)
> ##D   data(efc)
> ##D 
> ##D   # retrieve variable and value labels
> ##D   varlabs <- get_label(efc)
> ##D 
> ##D   # recveive first item of COPE-index scale
> ##D   start <- which(colnames(efc) == "c83cop2")
> ##D   # recveive last item of COPE-index scale
> ##D   end <- which(colnames(efc) == "c88cop7")
> ##D 
> ##D   # create data frame with COPE-index scale
> ##D   mydf <- data.frame(efc[, c(start:end)])
> ##D   colnames(mydf) <- varlabs[c(start:end)]
> ##D 
> ##D   # we have high correlations here, because all items
> ##D   # belong to one factor.
> ##D   tab_corr(mydf, p.numeric = TRUE)
> ##D 
> ##D   # auto-detection of labels, only lower triangle
> ##D   tab_corr(efc[, c(start:end)], triangle = "lower")
> ##D 
> ##D   # auto-detection of labels, only lower triangle, all correlation
> ##D   # values smaller than 0.3 are not shown in the table
> ##D   tab_corr(efc[, c(start:end)], triangle = "lower", val.rm = 0.3)
> ##D 
> ##D   # auto-detection of labels, only lower triangle, all correlation
> ##D   # values smaller than 0.3 are printed in blue
> ##D   tab_corr(efc[, c(start:end)], triangle = "lower",val.rm = 0.3,
> ##D            CSS = list(css.valueremove = 'color:blue;'))
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_df")
> ### * tab_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_df
> ### Title: Print data frames as HTML table.
> ### Aliases: tab_df tab_dfs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(iris)
> ##D data(mtcars)
> ##D tab_df(iris[1:5, ])
> ##D tab_dfs(list(iris[1:5, ], mtcars[1:5, 1:5]))
> ##D 
> ##D # sort 2nd column ascending
> ##D tab_df(iris[1:5, ], sort.column = 2)
> ##D 
> ##D # sort 2nd column descending
> ##D tab_df(iris[1:5, ], sort.column = -2)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("tab_fa")
> ### * tab_fa
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_fa
> ### Title: Summary of factor analysis as HTML table
> ### Aliases: tab_fa
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Data from the EUROFAMCARE sample dataset
> ##D library(sjmisc)
> ##D library(GPArotation)
> ##D data(efc)
> ##D 
> ##D # recveive first item of COPE-index scale
> ##D start <- which(colnames(efc) == "c82cop1")
> ##D # recveive last item of COPE-index scale
> ##D end <- which(colnames(efc) == "c90cop9")
> ##D # auto-detection of labels
> ##D if (interactive()) {
> ##D   tab_fa(efc[, start:end])
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_itemscale")
> ### * tab_itemscale
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_itemscale
> ### Title: Summary of item analysis of an item scale as HTML table
> ### Aliases: tab_itemscale sjt.itemanalysis
> 
> ### ** Examples
> 
> # Data from the EUROFAMCARE sample dataset
> library(sjmisc)
> library(sjlabelled)
> data(efc)
> 
> # retrieve variable and value labels
> varlabs <- get_label(efc)
> 
> # recveive first item of COPE-index scale
> start <- which(colnames(efc) == "c82cop1")
> # recveive last item of COPE-index scale
> end <- which(colnames(efc) == "c90cop9")
> 
> # create data frame with COPE-index scale
> mydf <- data.frame(efc[, start:end])
> colnames(mydf) <- varlabs[start:end]
> 
> ## Not run: 
> ##D if (interactive()) {
> ##D   tab_itemscale(mydf)
> ##D 
> ##D   # auto-detection of labels
> ##D   tab_itemscale(efc[, start:end])
> ##D 
> ##D   # Compute PCA on Cope-Index, and perform a
> ##D   # item analysis for each extracted factor.
> ##D   indices <- tab_pca(mydf)$factor.index
> ##D   tab_itemscale(mydf, factor.groups = indices)
> ##D 
> ##D   # or, equivalent
> ##D   tab_itemscale(mydf, factor.groups = "auto")
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()

detaching 'package:sjlabelled', 'package:sjmisc'

> nameEx("tab_pca")
> ### * tab_pca
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_pca
> ### Title: Summary of principal component analysis as HTML table
> ### Aliases: tab_pca
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Data from the EUROFAMCARE sample dataset
> ##D library(sjmisc)
> ##D data(efc)
> ##D 
> ##D # recveive first item of COPE-index scale
> ##D start <- which(colnames(efc) == "c82cop1")
> ##D # recveive last item of COPE-index scale
> ##D end <- which(colnames(efc) == "c90cop9")
> ##D # auto-detection of labels
> ##D if (interactive()) {
> ##D   tab_pca(efc[, start:end])
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_stackfrq")
> ### * tab_stackfrq
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_stackfrq
> ### Title: Summary of stacked frequencies as HTML table
> ### Aliases: tab_stackfrq
> 
> ### ** Examples
> 
> # -------------------------------
> # random sample
> # -------------------------------
> # prepare data for 4-category likert scale, 5 items
> likert_4 <- data.frame(
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.2, 0.3, 0.1, 0.4))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.1))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.25, 0.1, 0.4, 0.25))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.1, 0.4, 0.4, 0.1))),
+   as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.35, 0.25, 0.15, 0.25)))
+ )
> 
> # create labels
> levels_4 <- c("Independent", "Slightly dependent",
+               "Dependent", "Severely dependent")
> 
> # create item labels
> items <- c("Q1", "Q2", "Q3", "Q4", "Q5")
> 
> # plot stacked frequencies of 5 (ordered) item-scales
> ## Not run: 
> ##D if (interactive()) {
> ##D   tab_stackfrq(likert_4, value.labels = levels_4, var.labels = items)
> ##D 
> ##D   # -------------------------------
> ##D   # Data from the EUROFAMCARE sample dataset
> ##D   #  Auto-detection of labels
> ##D   # -------------------------------
> ##D   data(efc)
> ##D   # recveive first item of COPE-index scale
> ##D   start <- which(colnames(efc) == "c82cop1")
> ##D   # recveive first item of COPE-index scale
> ##D   end <- which(colnames(efc) == "c90cop9")
> ##D 
> ##D   tab_stackfrq(efc[, c(start:end)], alternate.rows = TRUE)
> ##D 
> ##D   tab_stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
> ##D                show.n = TRUE, show.na = TRUE)
> ##D 
> ##D   # --------------------------------
> ##D   # User defined style sheet
> ##D   # --------------------------------
> ##D   tab_stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
> ##D                show.total = TRUE, show.skew = TRUE, show.kurtosis = TRUE,
> ##D                CSS = list(css.ncol = "border-left:1px dotted black;",
> ##D                           css.summary = "font-style:italic;"))
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tab_xtab")
> ### * tab_xtab
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tab_xtab
> ### Title: Summary of contingency tables as HTML table
> ### Aliases: tab_xtab sjt.xtab
> 
> ### ** Examples
> 
> # prepare sample data set
> data(efc)
> 
> # print simple cross table with labels
> ## Not run: 
> ##D if (interactive()) {
> ##D   tab_xtab(efc$e16sex, efc$e42dep)
> ##D 
> ##D   # print cross table with manually set
> ##D   # labels and expected values
> ##D   tab_xtab(
> ##D     efc$e16sex,
> ##D     efc$e42dep,
> ##D     var.labels = c("Elder's gender", "Elder's dependency"),
> ##D     show.exp = TRUE
> ##D   )
> ##D 
> ##D   # print minimal cross table with labels, total col/row highlighted
> ##D   tab_xtab(efc$e16sex, efc$e42dep, show.cell.prc = FALSE, emph.total = TRUE)
> ##D 
> ##D   # User defined style sheet
> ##D   tab_xtab(efc$e16sex, efc$e42dep,
> ##D            CSS = list(css.table = "border: 2px solid;",
> ##D                       css.tdata = "border: 1px solid;",
> ##D                       css.horline = "border-bottom: double blue;"))
> ##D 
> ##D   # ordinal data, use Kendall's tau
> ##D   tab_xtab(efc$e42dep, efc$quol_5, statistics = "kendall")
> ##D 
> ##D   # calculate Spearman's rho, with continuity correction
> ##D   tab_xtab(
> ##D     efc$e42dep,
> ##D     efc$quol_5,
> ##D     statistics = "spearman",
> ##D     exact = FALSE,
> ##D     continuity = TRUE
> ##D   )
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("view_df")
> ### * view_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: view_df
> ### Title: View structure of labelled data frames
> ### Aliases: view_df
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # init dataset
> ##D data(efc)
> ##D 
> ##D # view variables
> ##D view_df(efc)
> ##D 
> ##D # view variables w/o values and value labels
> ##D view_df(efc, show.values = FALSE, show.labels = FALSE)
> ##D 
> ##D # view variables including variable typed, orderd by name
> ##D view_df(efc, sort.by.name = TRUE, show.type = TRUE)
> ##D 
> ##D # User defined style sheet
> ##D view_df(efc,
> ##D         CSS = list(css.table = "border: 2px solid;",
> ##D                    css.tdata = "border: 1px solid;",
> ##D                    css.arc = "color:blue;"))
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  42.81 1.66 47.01 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
