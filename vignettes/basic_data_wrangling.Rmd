---
title: "Basic Data Wrangling"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  \usepackage[utf8]{inputenc}
  %\VignetteIndexEntry{Basic Data Wrangling}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r message=FALSE, warning=FALSE, include=FALSE}
library(knitr)
options(knitr.kable.NA = "")
knitr::opts_chunk$set(
  eval = FALSE,
  message = FALSE,
  warning = FALSE,
  dpi = 300
)

pkgs <- c(
  "datawizard",
  "tidyr",
  "dplyr",
  "see",
  "ggplot2",
  "parameters",
  "lme4"
)

if (!all(sapply(pkgs, requireNamespace, quietly = TRUE))) {
  knitr::opts_chunk$set(eval = FALSE)
}
```


```{css, echo=FALSE, eval = TRUE}
.datawizard, .datawizard > .sourceCode {
  background-color: #e6e6ff;
}
.tidyverse, .tidyverse > .sourceCode {
  background-color: #d9f2e5;
}
```

`datawizard` package aims to make basic data wrangling easier than 
with base R. The data wrangling workflow it supports is similar to the one
supported by the tidyverse package combination of `dplyr` and `tidyr`. But,
one of its main features is that it has a very few dependencies: `stats` and `utils`
(included in base R) and `insight`, which is the core package of the _easystats_ 
ecosystem. This package grew organically to simultaneously satisfy the 
"0 non-base hard dependency" principle of _easystats_ and the data wrangling needs
of the constituent packages in this ecosystem.
One drawback of this genesis is that not all features of the 
`tidyverse` packages are supported since only those features have been implemented 
that were necessary for _easystats_ ecosystem. When needed, we will thus rely on base R,
or on [`{poorman}`](https://github.com/nathaneastwood/poorman/) package. It is also
important to note that `datawizard` was designed so that it avoids namespace 
collisions with `tidyverse` packages.

In this article, we will see how to go through basic data wrangling steps with 
`datawizard`. We will also compare it to the `tidyverse` syntax for achieving the same. 
This way, if you decide to make the switch, you can easily find the translations here.
This vignette is largely inspired from `dplyr`'s [Getting started vignette](https://dplyr.tidyverse.org/articles/dplyr.html).

```{r eval = TRUE}
library(dplyr)
library(tidyr)
library(datawizard)
```


# Equivalence with dplyr / tidyr

## Filtering

`data_filter()` is a wrapper around `subset()`. Therefore, if you want to have
several filtering conditions, you need to use `&`. Separating the conditions
with a comma as in `dplyr::filter()` will only apply the first condition.

:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r filter, class.source = "datawizard"}
# ---------- datawizard -----------
starwars %>%
  data_filter(skin_color == "light" & eye_color == "brown")
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
starwars %>% 
  filter(skin_color == "light", eye_color == "brown")
```
:::

::::

```{r filter, eval = TRUE, echo = FALSE}
```


<!-- Shorten output to make it easier to read: -->
```{r, echo = FALSE, eval = TRUE}
starwars <- head(starwars)
```




## Selecting

`data_select()` is the equivalent of `dplyr::select()`. The main difference 
between these two functions is that `data_select()` uses two arguments (`select`
and `exclude`) and requires quoted column names, while `dplyr::select()` accepts
any unquoted column names.  

:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r select1, class.source = "datawizard"}
# ---------- datawizard -----------
starwars %>% 
  data_select(select = c("hair_color", "skin_color", "eye_color")) 
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
starwars %>% 
  select(hair_color, skin_color, eye_color)
```
:::

::::

```{r select1, eval = TRUE, echo = FALSE}
```

:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r select2, class.source = "datawizard"}
# ---------- datawizard -----------
starwars %>% 
  data_select(select = -ends_with("color")) 
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
starwars %>% 
  select(-ends_with("color")) 
```
:::

::::

```{r select2, eval = TRUE, echo = FALSE}
```

:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r select3, class.source = "datawizard"}
# ---------- datawizard -----------
starwars %>% 
  data_select(select = -hair_color:eye_color)
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
starwars %>% 
  select(!(hair_color:eye_color))
```
:::

::::

```{r select3, eval = TRUE, echo = FALSE}
```


:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r select4, class.source = "datawizard"}
# ---------- datawizard -----------
starwars %>% 
  data_select(exclude = regex("color$")) 
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
starwars %>% 
  select(-contains("color$")) 
```
:::

::::

```{r select4, eval = TRUE, echo = FALSE}
```


:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r select5, class.source = "datawizard"}
# ---------- datawizard -----------
starwars %>% 
  data_select(select = is.numeric) 
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
starwars %>% 
  select(where(is.numeric)) 
```
:::

::::

```{r select5, eval = TRUE, echo = FALSE}
```

You can find a list of all the select helpers with `?data_select`.



## Renaming

`data_rename()` is the equivalent of `dplyr::rename()` but the syntax between the 
two is different. While `dplyr::rename()` takes each new-old pair of column
names, `data_rename()` takes first the list of columns to rename, and then takes 
a vector of new names that must be of the same length.

:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r rename1, class.source = "datawizard"}
# ---------- datawizard -----------
starwars %>% 
  data_rename(
    pattern = c("sex", "hair_color", "eye_color"),
    replacement = c("Sex", "Hair Color", "Eye Color")
  )
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
starwars %>%
  rename(
    Sex = sex,
    "Hair Color" = hair_color,
    "Eye Color" = eye_color
  )
```
:::

::::

```{r rename1, eval = TRUE, echo = FALSE}
```

The way `data_rename()` is designed makes it easy to apply the same modifications 
to a vector of column names. For example, we can remove underscores and use 
TitleCase with the following code:

```{r rename2}
to_rename <- names(starwars)

starwars %>% 
  data_rename(
    pattern = to_rename,
    replacement = tools::toTitleCase(gsub("_", " ", to_rename))
  )
```

```{r rename2, eval = TRUE, echo = FALSE}
```

It is also possible to add a prefix or a suffix to all or a subset of variables 
with `data_addprefix()` and `data_addsuffix()`. The argument `select` accepts 
all select helpers that we saw above with `data_select()`:

```{r rename3}
starwars %>% 
  data_addprefix(
    pattern = "OLD.",
    select = contains("color")
  ) %>% 
  data_addsuffix(
    pattern = ".NEW",
    select = -contains("color")
  )
```

```{r rename3, eval = TRUE, echo = FALSE}
```


## Reshaping

### Longer

Reshaping data from wide to long or from long to wide format can be done with
`reshape_longer()` and `reshape_wider()`. These functions were designed to match 
`tidyr::pivot_longer()` and `tidyr::pivot_wider()` arguments, so that the only 
thing to do is to change the function name. However, not all of 
`tidyr::pivot_longer()` and `tidyr::pivot_wider()` features are available yet. 

We will use the `relig_income` dataset, as in the [`tidyr` vignette](https://tidyr.tidyverse.org/articles/pivot.html).

```{r eval = TRUE}
relig_income
```


We would like to reshape this dataset to have 3 columns: religion, count, and 
income. The column "religion" doesn't need to change, so we exclude it with 
`-religion`. Then, each remaining column corresponds to an income category. 
Therefore, we want to move all these column names to a single column called 
"income". Finally, the values corresponding to each of these columns will be 
reshaped to be in a single new column, called "count".

:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r pivot1, class.source = "datawizard"}
# ---------- datawizard -----------
relig_income %>% 
  reshape_longer(
    select = -religion, 
    colnames_to = "income", 
    values_to = "count"
  )
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
relig_income %>% 
  pivot_longer(
    !religion, 
    names_to = "income", 
    values_to = "count"
  )
```
:::

::::

```{r pivot1, eval = TRUE, echo = FALSE}
```


To explore a bit more the arguments of `reshape_longer()`, we will use another
dataset: the `billboard` dataset.
```{r eval = TRUE}
billboard
```

:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r pivot2, class.source = "datawizard"}
# ---------- datawizard -----------
billboard %>% 
  reshape_longer(
    select = starts_with("wk"), 
    colnames_to = "week", 
    values_to = "rank"
  ) %>% 
  data_filter(!is.na(rank))
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  )
```
:::

::::

```{r pivot2, eval = TRUE, echo = FALSE}
```

Note that `pivot_longer()` has an argument that is not supported by `reshape_longer()`.
This can be simply done in an additional step with `data_filter()`.


### Wider

Once again, we use an example in the `tidyr` vignette to show how close `reshape_wider()`
and `pivot_wider()` are:
```{r eval=TRUE}
fish_encounters
```


:::: {style="display: grid; grid-template-columns: 50% 50%; grid-column-gap: 10px;"}

::: {}

```{r pivot3, class.source = "datawizard"}
# ---------- datawizard -----------
fish_encounters %>% 
  reshape_wider(
    names_from = "station", 
    values_from = "seen",
    values_fill = 0
  ) 
```
:::

::: {}

```{r, class.source = "tidyverse"}
# ---------- tidyverse -----------
fish_encounters %>% 
  pivot_wider(
    names_from = station, 
    values_from = seen,
    values_fill = 0
  )
```
:::

::::

```{r pivot3, eval = TRUE, echo = FALSE}
```




# Other useful functions

`datawizard` contains other functions that are not necessarily included in 
`dplyr` or `tidyr`. Some of them are inspired from the package `janitor`. 

## Work with rownames

We can convert a column in rownames and move rownames to a new column with
`rownames_as_column()` and `column_as_rownames()`:

```{r eval = TRUE}
mtcars <- head(mtcars)

mtcars

mtcars2 <- mtcars %>% 
  rownames_as_column(var = "model")

mtcars2

mtcars2 %>% 
  column_as_rownames(var = "model")
```


## Work with column names

When dealing with messy data, it is sometimes useful to use a row as column
names, and vice versa. This can be done with `row_to_colnames()` and
`colnames_to_row()`.

```{r eval = TRUE}
x <- data.frame(X_1 = c(NA, "Title", 1:3),
                X_2 = c(NA, "Title2", 4:6))
x
x2 <- x %>%
  row_to_colnames(row = 2)
x2

x2 %>% 
  colnames_to_row()
```

